# Phase A2: Gentoo Portage Integration - Design ðŸ’¡ **[Proposed]**

**Duration**: 4-6 weeks (design phase)
**Dependencies**: Phase A1, Phase E4 (pup support recommended)

**Objective**: Design integration with Gentoo Portage as a subsystem for package management.

**Recommendation**: Implement Phase E4 (pup support) first, as it provides a simpler but similar package system to learn from before tackling Portage's complexity.

## Concept

We want to use Gentoo Portage as a subsystem, integrating `emerge` functionality into Maestro. This requires finding a common superset between umk packages, ebuilds, and pup packages.

## Key Design Challenges

1. **Common Interface**: umk, Portage, and pup have overlapping but not identical concepts
   - **USE flags**:
     - umk: Custom flags (GUI, MT, DEBUG) with multi-config builds
     - Portage: USE flags for conditional dependencies (one config per package)
     - pup: No USE flags (simpler model)
   - **Linking strategy**:
     - umk: Focuses on static linking, weak shared library support
     - Portage: Excels at shared libraries with SONAME tracking
     - pup: Cross-compilation focused, deploys to staging
   - **Build phases**:
     - umk: Workspace scan â†’ compile â†’ link
     - Portage: src_unpack â†’ src_prepare â†’ src_configure â†’ src_compile â†’ src_install
     - pup: download â†’ patch â†’ prebuild â†’ configure â†’ build â†’ deploy
   - **Package format**:
     - umk: .upp files (custom format)
     - Portage: .ebuild files (bash scripts)
     - pup: package.py (Python classes)

2. **Virtual Base Class Design** (Critical Architecture Decision):

   **We must have a base virtual class that can run ALL package management systems**:
   - **Portage** (Gentoo's package manager)
   - **pup** (Pedigree's package manager)
   - **umk-fork** (Maestro's fork/extension of U++ umk)
   - **Maestro native** (possibly our own competitor to Portage)

   This base class is the **foundation of Maestro's universal package management**.

   ```python
   # Base virtual interface - the universal package manager abstraction
   # This must be flexible enough to support ALL package management paradigms

   class PackageManager(ABC):
       """Universal package manager interface.

       This base class must support:
       - Simple systems (pup - no USE flags)
       - Complex systems (Portage - USE flags, ebuilds)
       - Multi-config systems (umk - multiple build configurations)
       - Future systems (Maestro's own package manager)
       """

       @abstractmethod
       def scan_packages(self, repository_path):
           """Scan repository for packages and metadata."""
           pass

       @abstractmethod
       def resolve_dependencies(self, package, config=None):
           """Resolve package dependencies.

           Args:
               package: Package to resolve dependencies for
               config: Optional configuration (USE flags, build config, etc.)

           Returns:
               Dependency graph with resolved packages
           """
           pass

       @abstractmethod
       def build_package(self, package, config=None):
           """Build package with specific configuration.

           Args:
               package: Package to build
               config: Optional build configuration

           Returns:
               Build result with artifacts
           """
           pass

       @abstractmethod
       def install_package(self, package, destination):
           """Install built package to destination."""
           pass

       @abstractmethod
       def get_package_metadata(self, package):
           """Get package metadata (name, version, dependencies, etc.)."""
           pass

       @abstractmethod
       def supports_feature(self, feature):
           """Check if this package manager supports a feature.

           Features: 'use_flags', 'multi_config', 'binary_packages',
                    'shared_libraries', 'cross_compile', etc.
           """
           pass

   # Concrete implementations

   class PortageManager(PackageManager):
       """Gentoo Portage implementation.

       Features:
       - USE flags for conditional dependencies
       - ebuild format (bash scripts)
       - Single configuration per package
       - Excellent shared library support (SONAME tracking)
       - Binary package support (binpkgs)
       """
       def supports_feature(self, feature):
           return feature in ['use_flags', 'binary_packages', 'shared_libraries']

   class PupManager(PackageManager):
       """Pedigree pup implementation.

       Features:
       - Python package definitions
       - Build phases (download, patch, configure, build, deploy)
       - No USE flags (simpler model)
       - Cross-compilation focused
       """
       def supports_feature(self, feature):
           return feature in ['cross_compile']

   class UmkManager(PackageManager):
       """U++ package manager implementation (Maestro fork).

       Features:
       - .upp package format
       - Multi-configuration builds (multiple USE flag combinations)
       - Static linking focused
       - Blitz builds (unity builds)
       """
       def supports_feature(self, feature):
           return feature in ['multi_config', 'blitz_build']

   class MaestroNativeManager(PackageManager):
       """Maestro's native package manager (future).

       This is our potential competitor to Portage, combining:
       - Best of Portage: USE flags, shared library support
       - Best of umk: Multi-configuration builds
       - Best of pup: Python-based simplicity
       - New features: Better cross-compilation, modern tooling
       """
       def supports_feature(self, feature):
           return feature in ['use_flags', 'multi_config', 'shared_libraries',
                             'binary_packages', 'cross_compile', 'blitz_build']
   ```

   **Design Principles**:
   1. **Maximum Flexibility**: Base class must not assume any specific paradigm
   2. **Feature Detection**: Use `supports_feature()` to query capabilities
   3. **Optional Configuration**: `config` parameter can be USE flags, build configs, or None
   4. **Extensibility**: Easy to add new package managers without breaking existing ones
   5. **No Duplicate Code**: Common functionality in base class, specifics in implementations

3. **USE Flag Compatibility**:
   - Portage: One USE flag combination per package
   - umk: Can build multiple USE flag combinations simultaneously
   - **Design decision**: Support superset of both

4. **Shared Library Handling**:
   - Portage: Excellent shared library support (SONAME, dependencies)
   - umk: Weak shared library support, focuses on static linking
   - **Design decision**: Enhance umk with Portage-like shared library tracking

## Tasks

- [ ] **A2.1: Base Class Design** (CRITICAL FIRST STEP)
  - [ ] Design universal `PackageManager` base class
    - Must support ALL four systems: Portage, pup, umk, Maestro-native
    - Must be flexible enough for future package managers
    - Must not favor any single paradigm
  - [ ] Define core interface methods:
    - `scan_packages()` - universal package discovery
    - `resolve_dependencies()` - with optional config (USE flags, etc.)
    - `build_package()` - with optional config
    - `install_package()` - to staging/final destination
    - `get_package_metadata()` - name, version, deps, etc.
    - `supports_feature()` - capability detection
  - [ ] Define feature flags:
    - `use_flags` - Portage-style USE flags
    - `multi_config` - umk-style multiple configurations
    - `binary_packages` - pre-built package support
    - `shared_libraries` - SONAME tracking
    - `cross_compile` - cross-compilation support
    - `blitz_build` - unity/blitz builds
  - [ ] Document design rationale and trade-offs

- [ ] **A2.2: Architecture Research**
  - [ ] Study Portage architecture: https://github.com/gentoo/portage
  - [ ] Study pup architecture: `~/Dev/pedigree-apps/support/`
  - [ ] Study umk architecture: `~/upp/uppsrc/umk/`
  - [ ] Identify key Portage components:
    - Package dependency resolution (emerge)
    - ebuild parsing and execution
    - USE flag system
    - Shared library tracking (NEEDED.ELF.2)
    - Binary package support (binpkgs)
  - [ ] Map Portage concepts to Maestro base class
  - [ ] Map pup concepts to Maestro base class
  - [ ] Map umk concepts to Maestro base class
  - [ ] Identify commonalities and differences

- [ ] **A2.3: USE Flag System Design**
  - [ ] Support Portage USE flags
  - [ ] Support umk flags (GUI, MT, etc.)
  - [ ] Design flag inheritance
  - [ ] Design conditional dependencies

- [ ] **A2.4: Multi-Configuration Support**
  - [ ] Design how to handle umk's multi-config builds
  - [ ] Design how to extend Portage beyond single-config
  - [ ] Design configuration selection interface

- [ ] **A2.5: Shared Library Enhancement**
  - [ ] Design shared library tracking for umk
  - [ ] Design SONAME handling
  - [ ] Design dependency tracking
  - [ ] Integration with Portage's shared library system

## Deliverables:
- Architecture document for Portage integration
- Common interface specification
- USE flag system design
- Multi-configuration design

## Test Criteria:
- Design covers both Portage and umk use cases
- Interface is extensible
- USE flags are compatible